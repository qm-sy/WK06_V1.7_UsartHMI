C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        02/25/2025 10:35:43 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MODBUS_RTU
OBJECT MODULE PLACED IN ..\Output\hex\modbus_rtu.obj
COMPILER INVOKED BY: D:\APP\Keil_v5\C51\BIN\C51.EXE ..\Emembed\Src\modbus_rtu.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..
                    -\BSP\Inc;..\Core\Inc;..\Drivers;..\Emembed\Inc;..\Middlewares;..\SYSTEM\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\modbus_
                    -rtu.lst) OBJECT(..\Output\hex\modbus_rtu.obj)

line level    source

   1          #include "modbus_rtu.h"
   2          
   3          MODBIS_INFO modbus;
   4          
   5          /**
   6           * @brief       modbus_rtu  无奇偶校验
   7           *
   8           * @param   void
   9           *
  10           * @return  void 
  11          **/
  12          void Modbus_Event( void )
  13          {
  14   1          uint16_t crc,rccrc;
  15   1      
  16   1          /*1.接收完毕                                           */
  17   1          if( rs485.RX4_rcv_end_Flag == 1 )
  18   1          {
  19   2              /*2.清空接收完毕标志位                              */    
  20   2              rs485.RX4_rcv_end_Flag = 0;
  21   2      
  22   2              /*3.CRC校验                                         */
  23   2              crc = MODBUS_CRC16(rs485.RX4_buf, rs485.RX4_rcv_cnt-2);
  24   2              rccrc = (rs485.RX4_buf[rs485.RX4_rcv_cnt-2]<<8) | (rs485.RX4_buf[rs485.RX4_rcv_cnt-1]);
  25   2      
  26   2              /*4.清空接收计数                                    */
  27   2              rs485.RX4_rcv_cnt = 0; 
  28   2      
  29   2              /*5.CRC校验通过，进行地址域校验                      */
  30   2              if( crc == rccrc )
  31   2              {
  32   3                  /*6.地址域校验通过，进入相应功能函数进行处理      */
  33   3                  if( rs485.RX4_buf[0] == MY_ADDR )
  34   3                  {
  35   4                      switch ( rs485.RX4_buf[1] )
  36   4                      {
  37   5                          case 0x03:
  38   5                              Modbus_Fun3();
  39   5                              break;
  40   5      
  41   5                          case 0x04:
  42   5                              Modbus_Fun4();
  43   5                              break;
  44   5      
  45   5                          case 0x06:
  46   5                              Modbus_Fun6();
  47   5                              break;  
  48   5      
  49   5                          case 0x10:  
  50   5                              Modbus_Fun16();
  51   5      
  52   5                          default:
  53   5                              break;
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        02/25/2025 10:35:43 PAGE 2   

  54   5                      }
  55   4                  }
  56   3              }
  57   2          }
  58   1      }
  59          
  60          /**
  61           * @brief       读输出寄存器  03
  62           *
  63           * @param   void
  64           *
  65           * @return  void 
  66          **/
  67          void Modbus_Fun3( void )
  68          {
  69   1          uint16_t i;
  70   1      
  71   1          modbus.send_value_addr  = 3;                 //DATA1 H 位置
  72   1          modbus.byte_cnt   = (rs485.RX4_buf[4]<<8 | rs485.RX4_buf[5]) *2;
  73   1          modbus.start_addr = rs485.RX4_buf[2]<<8 | rs485.RX4_buf[3];
  74   1      
  75   1          rs485.TX4_buf[0]  = MY_ADDR;                //Addr
  76   1          rs485.TX4_buf[1]  = 0x03;                   //Fun
  77   1          rs485.TX4_buf[2]  = modbus.byte_cnt;        //Byte Count
  78   1      
  79   1          for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++ )
  80   1          {
  81   2              /*    每次循环前初始化byte_info                       */
  82   2              modbus.byte_info_H = modbus.byte_info_L = 0X00;
  83   2              switch (i)
  84   2              {
  85   3                  /*  40001  两路PWM 开关状态及风速查询                 */
  86   3                  case 0:
  87   3      
  88   3                      break;
  89   3      
  90   3                  /*  40002  LED开关状态查询                          */
  91   3                  case 1:
  92   3      
  93   3                       break;
  94   3      
  95   3                  /*  40003  220V CH4开关状态及功率查询               */
  96   3                  case 2:
  97   3      
  98   3                      break;
  99   3      
 100   3                  /*  40004 NTC1 NTC2 alarm value查询                       */
 101   3                  case 3:
 102   3           
 103   3                      break;
 104   3      
 105   3                  /*  40005 NTC3 alarm value查询                            */
 106   3                  case 4:
 107   3             
 108   3                      break;
 109   3      
 110   3                  default:
 111   3                      break;
 112   3              }
 113   2              rs485.TX4_buf[modbus.send_value_addr++] = modbus.byte_info_H;
 114   2              rs485.TX4_buf[modbus.send_value_addr++] = modbus.byte_info_L;
 115   2          }
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        02/25/2025 10:35:43 PAGE 3   

 116   1          slave_to_master(3 + modbus.byte_cnt);
 117   1      }
 118          
 119          
 120          /**
 121           * @brief       读输入寄存器  04
 122           *
 123           * @param   void
 124           *
 125           * @return  void 
 126          **/
 127          void Modbus_Fun4( void )
 128          {
 129   1          uint16_t i;
 130   1      
 131   1          modbus.send_value_addr  = 3;                //DATA1 H 位置
 132   1          modbus.byte_cnt   = (rs485.RX4_buf[4]<<8 | rs485.RX4_buf[5]) *2;
 133   1          modbus.start_addr = rs485.RX4_buf[2]<<8 | rs485.RX4_buf[3];
 134   1      
 135   1          rs485.TX4_buf[0]  = MY_ADDR;                //Addr
 136   1          rs485.TX4_buf[1]  = 0x04;                   //Fun
 137   1          rs485.TX4_buf[2]  = modbus.byte_cnt;        //Byte Count
 138   1      
 139   1          for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++ )
 140   1          {
 141   2              /*    每次循环前初始化byte_info                       */
 142   2              modbus.byte_info_H = modbus.byte_info_L = 0X00;
 143   2              switch (i)
 144   2              {   
 145   3                  /*  30001 NTC1 NTC2温度查询                     */
 146   3                  case 0:
 147   3      
 148   3                      break;
 149   3      
 150   3                  /*  30002 NTC3 NTC4温度查询                     */    
 151   3                  case 1:
 152   3      
 153   3                      break;
 154   3      
 155   3                  /*    30003 2路IR查询                         */
 156   3                  case 2:    
 157   3       
 158   3                      break;
 159   3      
 160   3                  // /*    30004 I_OUT1 I_OUT2 电流查询              */
 161   3                  // case 3:    
 162   3                  //     modbus.byte_info_H = get_current(I_OUT2);     
 163   3                  //     modbus.byte_info_L = get_current(I_OUT1);     
 164   3                  //     break;
 165   3      
 166   3                  // /*    30005 I_OUT3 电流查询                     */
 167   3                  // case 4:    
 168   3                  //     modbus.byte_info_H = 0X00;                    
 169   3                  //     modbus.byte_info_L = get_current(I_OUT3);     
 170   3                  //     break;
 171   3      
 172   3                  default:
 173   3                      break;
 174   3              }
 175   2              rs485.TX4_buf[modbus.send_value_addr++] = modbus.byte_info_H;
 176   2              rs485.TX4_buf[modbus.send_value_addr++] = modbus.byte_info_L;
 177   2          }
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        02/25/2025 10:35:43 PAGE 4   

 178   1          slave_to_master(3 + modbus.byte_cnt);
 179   1       }
 180          
 181          /**
 182           * @brief       写单个输出寄存器  06
 183           *
 184           * @param   void
 185           *
 186           * @return  void 
 187          **/
 188          void Modbus_Fun6( void )
 189          {
 190   1          switch (rs485.RX4_buf[3])
 191   1          {
 192   2              /*  40001  两路PWM 开关状态及风速设置                 */
 193   2              case 0:             
 194   2      
 195   2      
 196   2                break;
 197   2      
 198   2              /*  40002  24V LED开关状态设置                          */
 199   2              case 1:                                         
 200   2      
 201   2                  break;
 202   2      
 203   2              /*  40003  220V 开关及大小设置                          */
 204   2              case 2:                                         
 205   2      
 206   2      
 207   2                  break;  
 208   2                  
 209   2              /*  40004  NTC1 NTC2 alarm value 设置                   */
 210   2              case 3:                                         
 211   2      
 212   2                  break;
 213   2      
 214   2              /*  40005  NTC3 alarm value 设置                        */
 215   2              case 4:                                         
 216   2      
 217   2                  break;
 218   2              default:
 219   2                  break;   
 220   2          }
 221   1      }
 222          
 223          /**
 224           * @brief       写多个输出寄存器  16
 225           *
 226           * @param   void
 227           *
 228           * @return  void 
 229          **/
 230          void Modbus_Fun16( void )
 231          {
 232   1          uint16_t crc;
 233   1          uint16_t i;
 234   1      
 235   1          modbus.rcv_value_addr = 7;                  //DATA1 H位置
 236   1          modbus.byte_cnt   = rs485.RX4_buf[6];
 237   1          modbus.start_addr = rs485.RX4_buf[2]<<8 | rs485.RX4_buf[3];
 238   1      
 239   1          memcpy(rs485.TX4_buf,rs485.RX4_buf,6);
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        02/25/2025 10:35:43 PAGE 5   

 240   1      
 241   1          for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++)
 242   1          {
 243   2              modbus.byte_info_H = rs485.RX4_buf[modbus.rcv_value_addr];
 244   2              modbus.byte_info_L = rs485.RX4_buf[modbus.rcv_value_addr + 1];
 245   2              switch (i)
 246   2              {
 247   3                  /*  40001  两路PWM 开关状态及风速设置                 */
 248   3                  case 0:
 249   3      
 250   3                      break;
 251   3                  
 252   3                  /*  40002  24V LED开关状态设置                          */
 253   3                  case 1:
 254   3      
 255   3                      break;
 256   3      
 257   3                  /*  40003  220V 开关及大小设置                          */
 258   3                  case 2:
 259   3      
 260   3                      break;
 261   3      
 262   3                  /*  40004  NTC1 NTC2 alarm value 设置                   */
 263   3                  case 3:
 264   3      
 265   3                      break;
 266   3      
 267   3                  /*  40005  NTC3 alarm value 设置                        */
 268   3                  case 4:
 269   3      
 270   3                      break;
 271   3      
 272   3                  default:
 273   3                      break;
 274   3              }
 275   2              modbus.rcv_value_addr += 2;         //从Value1_H →→ 从Value2_H
 276   2          }
 277   1          
 278   1          crc = MODBUS_CRC16(rs485.TX4_buf,6);
 279   1          rs485.TX4_buf[6] = crc>>8;                 //CRC H
 280   1          rs485.TX4_buf[7] = crc;                    //CRC L
 281   1      
 282   1          rs485.TX4_send_bytelength = 8;
 283   1      
 284   1          //DR2 = 1;                                   //485可以发送
 285   1          delay_ms(5);
 286   1          S2CON |= S4TI;  
 287   1      
 288   1          eeprom_data_record();                      //记录更改后的值
 289   1      }
 290          
 291          /**
 292           * @brief       crc校验函数
 293           * 
 294           * @param   buf：  Address(1 byte) +Funtion(1 byte) ）+Data(n byte)   
 295           * @param   length:数据长度           
 296           * 
 297            @return  crc16:crc校验的值 2byte
 298           */
 299          uint16_t MODBUS_CRC16(uint8_t *buf, uint8_t length)
 300          {
 301   1              uint8_t i;
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        02/25/2025 10:35:43 PAGE 6   

 302   1              uint16_t        crc16;
 303   1      
 304   1          /* 1, 预置16位CRC寄存器为0xffff（即全为1）                          */
 305   1              crc16 = 0xffff; 
 306   1      
 307   1              do
 308   1              {
 309   2              /* 2, 把8位数据与16位CRC寄存器的低位相异或，把结果放于CRC寄存器     */    
             -    
 310   2                      crc16 ^= (uint16_t)*buf;                //
 311   2                      for(i=0; i<8; i++)              
 312   2                      {
 313   3                  /* 3, 如果最低位为1，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位 再异或0xA001    */
 314   3                              if(crc16 & 1)
 315   3                  {
 316   4                      crc16 = (crc16 >> 1) ^ 0xA001;
 317   4                  }
 318   3                  /* 4, 如果最低位为0，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位                */
 319   3                  else
 320   3                  {
 321   4                      crc16 >>= 1;
 322   4                  }           
 323   3                      }
 324   2                      buf++;
 325   2              }while(--length != 0);
 326   1      
 327   1              return  (crc16);
 328   1      }
 329          
 330          /**
 331           * @brief       从机回复主机
 332           *  
 333           * @param   length:数据长度           
 334           * 
 335            @return  crc16:crc校验的值 2byte
 336           */
 337          void slave_to_master(uint8_t length)
 338          {
 339   1          uint16_t crc;
 340   1      
 341   1          crc = MODBUS_CRC16(rs485.TX4_buf,length);
 342   1      
 343   1          rs485.TX4_buf[length] = crc>>8;                 //CRC H
 344   1          rs485.TX4_buf[length+1] = crc;                  //CRC L
 345   1      
 346   1          rs485.TX4_send_bytelength = length + 2;
 347   1      
 348   1          //DR2 = 1;                                        //485可以发送
 349   1          delay_ms(5);
 350   1          S2CON |= S4TI;                                  //开始发送
 351   1      }
 352          
 353          // void slave_scan( void )
 354          // {
 355          //     uint8_t send_buf[12];
 356          //     uint16_t crc;
 357          //     if( rs485.send_scan_flag == 1)
 358          //     {
 359          //         send_buf[0] = 0x35;
 360          //         send_buf[1] = 0x03;
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        02/25/2025 10:35:43 PAGE 7   

 361          //         send_buf[2] = temp.temp_value1;
 362          //         send_buf[3] = temp.temp_value2;
 363          //         send_buf[4] = temp.temp_value3;
 364          //         send_buf[5] = get_current(I_OUT1); 
 365          //         send_buf[6] = get_current(I_OUT2); 
 366          //         send_buf[7] = get_current(I_OUT3); 
 367          //         send_buf[8] = ((PWMB_CCR8/184)<<4 | (PWMB_CCR8/184));
 368          //         if( INTCLKO & 0x10 )
 369          //         {
 370          //             send_buf[9] = 0x01;                             //220V运行状态
 371          //         }else
 372          //         {
 373          //             send_buf[9] = 0x00;
 374          //         }
 375          //         send_buf[10]= (uint8_t)((ac_220.time_delay-58000)/75);
 376          
 377          //         crc = MODBUS_CRC16(send_buf,11);
 378              
 379          //         send_buf[11] = crc>>8;
 380          //         send_buf[12] = crc;
 381              
 382          //         memcpy(rs485.TX4_buf,send_buf,13);
 383              
 384          //         rs485.TX4_send_bytelength = 13;
 385          //         DR2 = 1;                                        //485可以发送
 386          //         delay_ms(5);
 387          //         S2CON |= S4TI;                                  //开始发送
 388          
 389          //         rs485.send_scan_flag = 0;
 390          //         //DR2 = 0;
 391          //     }  
 392          // }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    750    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      7       3
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
