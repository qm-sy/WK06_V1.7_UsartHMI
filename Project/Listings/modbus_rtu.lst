C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        02/25/2025 21:23:38 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MODBUS_RTU
OBJECT MODULE PLACED IN ..\Output\hex\modbus_rtu.obj
COMPILER INVOKED BY: D:\APP\Keil_STM32\C51\BIN\C51.EXE ..\Emembed\Src\modbus_rtu.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR
                    -(..\BSP\Inc;..\Core\Inc;..\Drivers;..\Emembed\Inc;..\Middlewares;..\SYSTEM\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\modb
                    -us_rtu.lst) OBJECT(..\Output\hex\modbus_rtu.obj)

line level    source

   1          #include "modbus_rtu.h"
   2          
   3          MODBIS_INFO modbus;
   4          
   5          /**
   6           * @brief       modbus_rtu  无奇偶校验
   7           *
   8           * @param   void
   9           *
  10           * @return  void 
  11          **/
  12          void Modbus_Event( void )
  13          {
  14   1          //uint16_t crc,rccrc;
  15   1      
  16   1          /*1.接收完毕                                           */
  17   1          if( rs485.RX4_rcv_end_Flag == 1 )
  18   1          {
  19   2              /*2.清空接收完毕标志位                              */    
  20   2              rs485.RX4_rcv_end_Flag = 0;
  21   2      
  22   2              /*3.CRC校验                                         */
  23   2              // crc = MODBUS_CRC16(rs485.RX4_buf, rs485.RX4_rcv_cnt-2);
  24   2              // rccrc = (rs485.RX4_buf[rs485.RX4_rcv_cnt-2]<<8) | (rs485.RX4_buf[rs485.RX4_rcv_cnt-1]);
  25   2      
  26   2              /*4.清空接收计数                                    */
  27   2              rs485.RX4_rcv_cnt = 0; 
  28   2      
  29   2              /*5.CRC校验通过，进行地址域校验                      */
  30   2              // if( crc == rccrc )
  31   2              // {
  32   2                  /*6.地址域校验通过，进入相应功能函数进行处理      */
  33   2              if( rs485.RX4_buf[0] == MY_ADDR )
  34   2              {
  35   3                  switch ( rs485.RX4_buf[1] )
  36   3                  {
  37   4                      case 0x15:
  38   4                          rs485.TX4_buf[0] = 0x51;
  39   4                          rs485.TX4_buf[0] = 0x15;
  40   4                          rs485.TX4_send_bytelength = 2;
  41   4                          S4CON |= S4TI;                                  //开始发送
  42   4                          break;
  43   4      
  44   4                      case 0xA0:
  45   4                          EX0 = rs485.RX4_buf[2];
  46   4                          break;
  47   4      
  48   4                      case 0xA1:
  49   4                          pwm8_crl(rs485.RX4_buf[2]);
  50   4                          break;
  51   4      
  52   4                      case 0xA2:
  53   4                          buzzer = rs485.RX4_buf[2];
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        02/25/2025 21:23:38 PAGE 2   

  54   4                          break;  
  55   4      
  56   4                      case 0xA3:  
  57   4                          pwm7_crl(rs485.RX4_buf[2]);
  58   4      
  59   4                      case 0xA4:  
  60   4                          DC_24V_out1(rs485.RX4_buf[2]);
  61   4      
  62   4                      case 0xA5:  
  63   4                          DC_24V_out2(rs485.RX4_buf[2]);
  64   4                      
  65   4                      case 0xA6:  
  66   4                          temp.temp_alarm_value1 = rs485.RX4_buf[2];
  67   4                          temp.temp_alarm_value2 = rs485.RX4_buf[3];
  68   4                          temp.temp_alarm_value3 = rs485.RX4_buf[4];
  69   4      
  70   4                      case 0xA7:  
  71   4                          pwm_info.stir_time = rs485.RX4_buf[2];
  72   4                          pwm_info.stir_wait_time = rs485.RX4_buf[3];
  73   4                          pwm_info.cir_time = rs485.RX4_buf[4];
  74   4                          pwm_info.cir_wait_time = rs485.RX4_buf[5];
  75   4      
  76   4                      default:
  77   4                          break;
  78   4                  // }
  79   4                  }
  80   3              }
  81   2          }
  82   1      }
  83          
  84          // /**
  85          //  * @brief    读输出寄存器  03
  86          //  *
  87          //  * @param   void
  88          //  *
  89          //  * @return  void 
  90          // **/
  91          // void Modbus_Fun3( void )
  92          // {
  93          //     uint16_t i;
  94          
  95          //     modbus.send_value_addr  = 3;                 //DATA1 H 位置
  96          //     modbus.byte_cnt   = (rs485.RX4_buf[4]<<8 | rs485.RX4_buf[5]) *2;
  97          //     modbus.start_addr = rs485.RX4_buf[2]<<8 | rs485.RX4_buf[3];
  98          
  99          //     rs485.TX4_buf[0]  = MY_ADDR;                //Addr
 100          //     rs485.TX4_buf[1]  = 0x03;                   //Fun
 101          //     rs485.TX4_buf[2]  = modbus.byte_cnt;        //Byte Count
 102          
 103          //     for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++ )
 104          //     {
 105          //         /*    每次循环前初始化byte_info                       */
 106          //         modbus.byte_info_H = modbus.byte_info_L = 0X00;
 107          //         switch (i)
 108          //         {
 109          //             /*  40001  两路PWM 开关状态及风速查询                 */
 110          //             case 0:
 111          
 112          //                 break;
 113          
 114          //             /*  40002  LED开关状态查询                          */
 115          //             case 1:
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        02/25/2025 21:23:38 PAGE 3   

 116          
 117          //                  break;
 118          
 119          //             /*  40003  220V CH4开关状态及功率查询               */
 120          //             case 2:
 121          
 122          //                 break;
 123          
 124          //             /*  40004 NTC1 NTC2 alarm value查询                       */
 125          //             case 3:
 126               
 127          //                 break;
 128          
 129          //             /*  40005 NTC3 alarm value查询                            */
 130          //             case 4:
 131                 
 132          //                 break;
 133          
 134          //             default:
 135          //                 break;
 136          //         }
 137          //         rs485.TX4_buf[modbus.send_value_addr++] = modbus.byte_info_H;
 138          //         rs485.TX4_buf[modbus.send_value_addr++] = modbus.byte_info_L;
 139          //     }
 140          //     slave_to_master(3 + modbus.byte_cnt);
 141          // }
 142          
 143          
 144          // /**
 145          //  * @brief    读输入寄存器  04
 146          //  *
 147          //  * @param   void
 148          //  *
 149          //  * @return  void 
 150          // **/
 151          // void Modbus_Fun4( void )
 152          // {
 153          //     uint16_t i;
 154          
 155          //     modbus.send_value_addr  = 3;                //DATA1 H 位置
 156          //     modbus.byte_cnt   = (rs485.RX4_buf[4]<<8 | rs485.RX4_buf[5]) *2;
 157          //     modbus.start_addr = rs485.RX4_buf[2]<<8 | rs485.RX4_buf[3];
 158          
 159          //     rs485.TX4_buf[0]  = MY_ADDR;                //Addr
 160          //     rs485.TX4_buf[1]  = 0x04;                   //Fun
 161          //     rs485.TX4_buf[2]  = modbus.byte_cnt;        //Byte Count
 162          
 163          //     for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++ )
 164          //     {
 165          //         /*    每次循环前初始化byte_info                       */
 166          //         modbus.byte_info_H = modbus.byte_info_L = 0X00;
 167          //         switch (i)
 168          //         {   
 169          //             /*  30001 NTC1 NTC2温度查询                     */
 170          //             case 0:
 171          
 172          //                 break;
 173          
 174          //             /*  30002 NTC3 NTC4温度查询                     */    
 175          //             case 1:
 176          
 177          //                 break;
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        02/25/2025 21:23:38 PAGE 4   

 178          
 179          //             /*    30003 2路IR查询                         */
 180          //             case 2:    
 181           
 182          //                 break;
 183          
 184          //             // /*    30004 I_OUT1 I_OUT2 电流查询              */
 185          //             // case 3:    
 186          //             //     modbus.byte_info_H = get_current(I_OUT2);     
 187          //             //     modbus.byte_info_L = get_current(I_OUT1);     
 188          //             //     break;
 189          
 190          //             // /*    30005 I_OUT3 电流查询                     */
 191          //             // case 4:    
 192          //             //     modbus.byte_info_H = 0X00;                    
 193          //             //     modbus.byte_info_L = get_current(I_OUT3);     
 194          //             //     break;
 195          
 196          //             default:
 197          //                 break;
 198          //         }
 199          //         rs485.TX4_buf[modbus.send_value_addr++] = modbus.byte_info_H;
 200          //         rs485.TX4_buf[modbus.send_value_addr++] = modbus.byte_info_L;
 201          //     }
 202          //     slave_to_master(3 + modbus.byte_cnt);
 203          //  }
 204          
 205          // /**
 206          //  * @brief    写单个输出寄存器  06
 207          //  *
 208          //  * @param   void
 209          //  *
 210          //  * @return  void 
 211          // **/
 212          // void Modbus_Fun6( void )
 213          // {
 214          //     switch (rs485.RX4_buf[3])
 215          //     {
 216          //         /*  40001  两路PWM 开关状态及风速设置                 */
 217          //         case 0:             
 218          
 219          
 220          //           break;
 221          
 222          //         /*  40002  24V LED开关状态设置                          */
 223          //         case 1:                                         
 224          
 225          //             break;
 226          
 227          //         /*  40003  220V 开关及大小设置                          */
 228          //         case 2:                                         
 229          
 230          
 231          //             break;  
 232                      
 233          //         /*  40004  NTC1 NTC2 alarm value 设置                   */
 234          //         case 3:                                         
 235          
 236          //             break;
 237          
 238          //         /*  40005  NTC3 alarm value 设置                        */
 239          //         case 4:                                         
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        02/25/2025 21:23:38 PAGE 5   

 240          
 241          //             break;
 242          //         default:
 243          //             break;   
 244          //     }
 245          // }
 246          
 247          // /**
 248          //  * @brief    写多个输出寄存器  16
 249          //  *
 250          //  * @param   void
 251          //  *
 252          //  * @return  void 
 253          // **/
 254          // void Modbus_Fun16( void )
 255          // {
 256          //     uint16_t crc;
 257          //     uint16_t i;
 258          
 259          //     modbus.rcv_value_addr = 7;                  //DATA1 H位置
 260          //     modbus.byte_cnt   = rs485.RX4_buf[6];
 261          //     modbus.start_addr = rs485.RX4_buf[2]<<8 | rs485.RX4_buf[3];
 262          
 263          //     memcpy(rs485.TX4_buf,rs485.RX4_buf,6);
 264          
 265          //     for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++)
 266          //     {
 267          //         modbus.byte_info_H = rs485.RX4_buf[modbus.rcv_value_addr];
 268          //         modbus.byte_info_L = rs485.RX4_buf[modbus.rcv_value_addr + 1];
 269          //         switch (i)
 270          //         {
 271          //             /*  40001  两路PWM 开关状态及风速设置                 */
 272          //             case 0:
 273          
 274          //                 break;
 275                      
 276          //             /*  40002  24V LED开关状态设置                          */
 277          //             case 1:
 278          
 279          //                 break;
 280          
 281          //             /*  40003  220V 开关及大小设置                          */
 282          //             case 2:
 283          
 284          //                 break;
 285          
 286          //             /*  40004  NTC1 NTC2 alarm value 设置                   */
 287          //             case 3:
 288          
 289          //                 break;
 290          
 291          //             /*  40005  NTC3 alarm value 设置                        */
 292          //             case 4:
 293          
 294          //                 break;
 295          
 296          //             default:
 297          //                 break;
 298          //         }
 299          //         modbus.rcv_value_addr += 2;         //从Value1_H →→ 从Value2_H
 300          //     }
 301              
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        02/25/2025 21:23:38 PAGE 6   

 302          //     crc = MODBUS_CRC16(rs485.TX4_buf,6);
 303          //     rs485.TX4_buf[6] = crc>>8;                 //CRC H
 304          //     rs485.TX4_buf[7] = crc;                    //CRC L
 305          
 306          //     rs485.TX4_send_bytelength = 8;
 307          
 308          //     //DR2 = 1;                                   //485可以发送
 309          //     delay_ms(5);
 310          //     S2CON |= S4TI;  
 311          
 312          //     eeprom_data_record();                      //记录更改后的值
 313          // }
 314          
 315          // /**
 316          //  * @brief    crc校验函数
 317          //  * 
 318          //  * @param   buf：  Address(1 byte) +Funtion(1 byte) ）+Data(n byte)   
 319          //  * @param   length:数据长度           
 320          //  * 
 321          //   @return  crc16:crc校验的值 2byte
 322          //  */
 323          // uint16_t MODBUS_CRC16(uint8_t *buf, uint8_t length)
 324          // {
 325          //      uint8_t i;
 326          //      uint16_t        crc16;
 327          
 328          //     /* 1, 预置16位CRC寄存器为0xffff（即全为1）                          */
 329          //      crc16 = 0xffff; 
 330          
 331          //      do
 332          //      {
 333          //         /* 2, 把8位数据与16位CRC寄存器的低位相异或，把结果放于CRC寄存器     */ 
             -       
 334          //              crc16 ^= (uint16_t)*buf;                //
 335          //              for(i=0; i<8; i++)              
 336          //              {
 337          //             /* 3, 如果最低位为1，把CRC寄存器的内容右移一位(朝低位)，用0填补最
             -高位 再异或0xA001    */
 338          //                      if(crc16 & 1)
 339          //             {
 340          //                 crc16 = (crc16 >> 1) ^ 0xA001;
 341          //             }
 342          //             /* 4, 如果最低位为0，把CRC寄存器的内容右移一位(朝低位)，用0填补最
             -高位                */
 343          //             else
 344          //             {
 345          //                 crc16 >>= 1;
 346          //             }                
 347          //              }
 348          //              buf++;
 349          //      }while(--length != 0);
 350          
 351          //      return  (crc16);
 352          // }
 353          
 354          // /**
 355          //  * @brief    从机回复主机
 356          //  *  
 357          //  * @param   length:数据长度           
 358          //  * 
 359          //   @return  crc16:crc校验的值 2byte
 360          //  */
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        02/25/2025 21:23:38 PAGE 7   

 361          // void slave_to_master(uint8_t length)
 362          // {
 363          //     uint16_t crc;
 364          
 365          //     crc = MODBUS_CRC16(rs485.TX4_buf,length);
 366          
 367          //     rs485.TX4_buf[length] = crc>>8;                 //CRC H
 368          //     rs485.TX4_buf[length+1] = crc;                  //CRC L
 369          
 370          //     rs485.TX4_send_bytelength = length + 2;
 371          
 372          //     //DR2 = 1;                                        //485可以发送
 373          //     delay_ms(5);
 374          //     S2CON |= S4TI;                                  //开始发送
 375          // }
 376          
 377          // // void slave_scan( void )
 378          // // {
 379          // //     uint8_t send_buf[12];
 380          // //     uint16_t crc;
 381          // //     if( rs485.send_scan_flag == 1)
 382          // //     {
 383          // //         send_buf[0] = 0x35;
 384          // //         send_buf[1] = 0x03;
 385          // //         send_buf[2] = temp.temp_value1;
 386          // //         send_buf[3] = temp.temp_value2;
 387          // //         send_buf[4] = temp.temp_value3;
 388          // //         send_buf[5] = get_current(I_OUT1); 
 389          // //         send_buf[6] = get_current(I_OUT2); 
 390          // //         send_buf[7] = get_current(I_OUT3); 
 391          // //         send_buf[8] = ((PWMB_CCR8/184)<<4 | (PWMB_CCR8/184));
 392          // //         if( INTCLKO & 0x10 )
 393          // //         {
 394          // //             send_buf[9] = 0x01;                             //220V运行状态
 395          // //         }else
 396          // //         {
 397          // //             send_buf[9] = 0x00;
 398          // //         }
 399          // //         send_buf[10]= (uint8_t)((ac_220.time_delay-58000)/75);
 400          
 401          // //         crc = MODBUS_CRC16(send_buf,11);
 402              
 403          // //         send_buf[11] = crc>>8;
 404          // //         send_buf[12] = crc;
 405              
 406          // //         memcpy(rs485.TX4_buf,send_buf,13);
 407              
 408          // //         rs485.TX4_send_bytelength = 13;
 409          // //         DR2 = 1;                                        //485可以发送
 410          // //         delay_ms(5);
 411          // //         S2CON |= S4TI;                                  //开始发送
 412          
 413          // //         rs485.send_scan_flag = 0;
 414          // //         //DR2 = 0;
 415          // //     }  
 416          // // }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    207    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      7    ----
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        02/25/2025 21:23:38 PAGE 8   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
